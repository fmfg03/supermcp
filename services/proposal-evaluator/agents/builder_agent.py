"""
BuilderAgent - Generates initial business proposals
"""

import asyncio
from typing import Dict, Any
from dataclasses import dataclass
from datetime import datetime

from ..utils.llm_client import LLMClient
from ..utils.logger import setup_logger

logger = setup_logger(__name__)

@dataclass 
class ProposalTemplate:
    """Template structure for proposals"""
    executive_summary: str
    problem_statement: str
    proposed_solution: str
    implementation_plan: str
    timeline: str
    budget: str
    expected_outcomes: str
    risk_assessment: str

class BuilderAgent:
    """
    Agent responsible for generating initial business proposals
    Uses advanced prompting techniques and structured templates
    """
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.llm_client = LLMClient(config.get("llm", {}))
        self.version = "1.0.0"
        
        # Prompt templates
        self.system_prompt = self._load_system_prompt()
        self.proposal_template = self._load_proposal_template()
        
    def _load_system_prompt(self) -> str:
        """Load system prompt for proposal generation"""
        return """You are a senior business consultant and proposal writer with 15+ years of experience.

Your expertise includes:
- Strategic business planning
- Financial modeling and ROI analysis  
- Risk assessment and mitigation
- Implementation planning
- Stakeholder communication

When generating proposals, you:
1. Analyze client context thoroughly
2. Identify key business drivers and pain points
3. Develop data-driven solutions
4. Structure proposals for maximum impact
5. Address potential objections proactively
6. Use persuasive but professional language

Always consider the perspectives of:
- CEO: Strategic alignment, competitive advantage, growth
- CFO: Financial impact, ROI, budget constraints, risk
- CMO: Market positioning, customer impact, brand alignment

Generate proposals that are:
- Clear and concise
- Data-driven where possible
- Actionable with specific steps
- Realistic in scope and timeline
- Compelling for decision makers"""

    def _load_proposal_template(self) -> str:
        """Load structured proposal template"""
        return """# Business Proposal: {title}

## Executive Summary
{executive_summary}

## Current Situation & Problem Statement
{problem_statement}

## Proposed Solution
{proposed_solution}

### Key Components
{solution_components}

### Unique Value Proposition
{value_proposition}

## Implementation Plan
{implementation_plan}

### Phase 1: {phase1_title}
{phase1_details}

### Phase 2: {phase2_title}
{phase2_details}

### Phase 3: {phase3_title}
{phase3_details}

## Timeline & Milestones
{timeline}

## Investment & Budget
{budget}

### Cost Breakdown
{cost_breakdown}

### ROI Projection
{roi_projection}

## Expected Outcomes & Benefits
{expected_outcomes}

### Quantifiable Benefits
{quantifiable_benefits}

### Strategic Benefits
{strategic_benefits}

## Risk Assessment & Mitigation
{risk_assessment}

## Success Metrics & KPIs
{success_metrics}

## Next Steps
{next_steps}

---
*Generated by BuilderAgent v{version} on {timestamp}*"""

    async def generate_proposal(self, context) -> str:
        """
        Generate initial proposal based on context
        
        Args:
            context: ProposalContext object with client info, context, objectives
            
        Returns:
            Generated proposal as markdown string
        """
        logger.info(f"Generating proposal for {context.client} with tone: {context.tone}")
        
        try:
            # Build context-specific prompt
            prompt = self._build_generation_prompt(context)
            
            # Generate proposal content
            response = await self.llm_client.generate(
                system_prompt=self.system_prompt,
                user_prompt=prompt,
                temperature=0.7,
                max_tokens=4000
            )
            
            # Structure the response using template
            structured_proposal = self._structure_proposal(response, context)
            
            logger.info(f"Generated proposal: {len(structured_proposal)} characters")
            return structured_proposal
            
        except Exception as e:
            logger.error(f"Failed to generate proposal: {e}")
            raise
    
    def _build_generation_prompt(self, context) -> str:
        """Build context-specific generation prompt"""
        
        objectives_text = "\n".join([f"- {obj}" for obj in context.objectives])
        constraints_text = ""
        if context.constraints:
            constraints_text = f"\n\nConstraints:\n" + "\n".join([f"- {const}" for const in context.constraints])
        
        tone_instructions = self._get_tone_instructions(context.tone)
        
        prompt = f"""Generate a comprehensive business proposal for the following client:

CLIENT: {context.client}

CONTEXT:
{context.context}

OBJECTIVES:
{objectives_text}
{constraints_text}

TONE & STYLE:
{tone_instructions}

Please generate a complete, persuasive business proposal that:
1. Addresses the client's specific context and challenges
2. Aligns with the stated objectives
3. Includes concrete implementation steps
4. Provides realistic timelines and budgets
5. Addresses potential stakeholder concerns
6. Uses the specified tone appropriately

Structure the proposal with clear sections for executive summary, problem statement, 
proposed solution, implementation plan, timeline, budget, expected outcomes, and risk assessment.

Make it compelling and professional, suitable for C-level decision makers."""

        return prompt
    
    def _get_tone_instructions(self, tone: str) -> str:
        """Get tone-specific instructions"""
        tone_map = {
            "professional": "Use professional, formal language. Be authoritative but respectful. Focus on facts and data.",
            "aggressive": "Use confident, assertive language. Emphasize urgency and competitive advantages. Be bold in claims and recommendations.",
            "diplomatic": "Use collaborative, consultative language. Emphasize partnership and mutual benefits. Be tactful and considerate.",
            "technical": "Use precise, technical language. Include detailed specifications and methodologies. Appeal to technical expertise.",
            "executive": "Use high-level, strategic language. Focus on business impact and competitive positioning. Keep technical details minimal."
        }
        
        return tone_map.get(tone, tone_map["professional"])
    
    def _structure_proposal(self, content: str, context) -> str:
        """Structure the generated content using our template"""
        
        # For now, return the content as-is
        # In a production system, you might parse the content and structure it more formally
        timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")
        
        structured = f"""# Business Proposal for {context.client}

{content}

---
*Generated by SuperMCP BuilderAgent v{self.version} on {timestamp}*
*Tone: {context.tone.title()} | Client: {context.client}*"""

        return structured
    
    async def generate_variant(self, context, variant_type: str) -> str:
        """Generate a specific variant of the proposal"""
        
        variant_context = context.__class__(
            client=context.client,
            context=context.context,
            objectives=context.objectives,
            constraints=context.constraints,
            tone=variant_type
        )
        
        return await self.generate_proposal(variant_context)
    
    def get_generation_metadata(self) -> Dict[str, Any]:
        """Get metadata about the generation process"""
        return {
            "agent": "BuilderAgent",
            "version": self.version,
            "model": self.llm_client.model_name,
            "capabilities": [
                "contextual_analysis",
                "structured_proposals", 
                "tone_adaptation",
                "stakeholder_alignment"
            ]
        }